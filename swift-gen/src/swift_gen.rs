use super::Error;
use parser::ast::{Declaration, Document, DocumentItem, RuleSet, RuleSetItem, Value};
use std::cmp::Ordering;
use std::fs;
use std::io::prelude::*;
use std::path::Path;

pub fn gen_swift(doc: &Document, path: &Path, force_overwrite: bool) -> Result<(), Error> {
  let mut prefix =
    r#"// This file is automatically generated. Do not edit, your changes will be erased.

import UIKit

extension UIColor {
  enum Custom {
"#
    .to_owned();

  let suffix = r#"  }
}
"#;

  let tab = "  ";

  fn append_ruleset(
    mut prefix: &mut String,
    tab: &str,
    depth: usize,
    ruleset: &RuleSet,
    identifier: &str,
  ) {
    prefix.push_str(&format!(
      "{}enum {} {{\n",
      tab.repeat(depth),
      ruleset.identifier
    ));
    for item in ruleset.items.iter() {
      match item {
        RuleSetItem::RuleSet(r) => append_ruleset(
          &mut prefix,
          tab,
          depth + 1,
          &r,
          &format!("{}{}", identifier, r.identifier),
        ),
        RuleSetItem::Declaration(d) => {
          append_declaration(&mut prefix, tab, depth + 1, &d, identifier)
        }
      }
    }
    prefix.push_str(&format!("{}}}\n", tab.repeat(depth)));
  }

  fn append_declaration(
    prefix: &mut String,
    tab: &str,
    depth: usize,
    declaration: &Declaration<Value>,
    identifier: &str,
  ) {
    prefix.push_str(&format!(
      "{}static let {} = UIColor(named: \"{}\")!\n",
      tab.repeat(depth),
      declaration.identifier,
      format!("{}{}", identifier, declaration.identifier)
    ))
  }

  let mut items = doc.items.to_vec();

  items.sort_by(|a, b| match (a, b) {
    (DocumentItem::Declaration(_), DocumentItem::RuleSet(_)) => Ordering::Less,
    (DocumentItem::RuleSet(_), DocumentItem::Declaration(_)) => Ordering::Greater,
    (DocumentItem::RuleSet(a), DocumentItem::RuleSet(b)) => {
      a.identifier.partial_cmp(&b.identifier).unwrap()
    }
    (DocumentItem::Declaration(a), DocumentItem::Declaration(b)) => {
      a.identifier.partial_cmp(&b.identifier).unwrap()
    }
    (DocumentItem::Variable(_), DocumentItem::RuleSet(_)) => Ordering::Greater,
    (DocumentItem::Variable(_), DocumentItem::Declaration(_)) => Ordering::Greater,
    (DocumentItem::RuleSet(_), DocumentItem::Variable(_)) => Ordering::Less,
    (DocumentItem::Declaration(_), DocumentItem::Variable(_)) => Ordering::Less,
    (DocumentItem::Variable(_), DocumentItem::Variable(_)) => Ordering::Equal,
  });

  for item in items.iter() {
    match item {
      DocumentItem::RuleSet(r) => append_ruleset(&mut prefix, tab, 2, r, &r.identifier),
      DocumentItem::Declaration(d) => append_declaration(&mut prefix, tab, 2, d, ""),
      DocumentItem::Variable(_) => {}
    }
  }
  prefix.push_str(suffix);

  let data = prefix.as_bytes();

  if !force_overwrite && path.exists() {
    let mut existing_data = Vec::new();
    let mut existing_file = fs::File::open(&path)?;
    existing_file.read_to_end(&mut existing_data)?;

    if existing_data == data {
      return Err(Error::FileIsIdentical(path.to_str().unwrap().to_string()));
    }
  }

  fs::write(path, data)?;

  Ok(())
}
